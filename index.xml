<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Attitude is altitude</title>
    <link>https://godeamon.github.io/</link>
    <description>Attitude is altitude</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 18 Apr 2020 11:32:30 +0800</lastBuildDate>
    
    <atom:link href="https://godeamon.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Plan</title>
      <link>https://godeamon.github.io/post/plan/</link>
      <pubDate>Mon, 06 Apr 2020 10:41:03 +0800</pubDate>
      
      <guid>https://godeamon.github.io/post/plan/</guid>
      <description>&lt;h1 id=&#34;go-语言相关学习计划&#34;&gt;Go 语言相关学习计划&lt;/h1&gt;
&lt;p&gt;暂定自学路线&lt;/p&gt;
&lt;h2 id=&#34;go-源码&#34;&gt;Go 源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Go runtime&lt;/li&gt;
&lt;li&gt;Go mem&lt;/li&gt;
&lt;li&gt;Go map, chan, slice and so on source code&lt;/li&gt;
&lt;li&gt;Go epoll&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他项目源码&#34;&gt;其他项目源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;etcd&lt;/li&gt;
&lt;li&gt;docker&lt;/li&gt;
&lt;li&gt;ethereum&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;操作系统&lt;/li&gt;
&lt;li&gt;linux&lt;/li&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如何设计缓存系统&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go Slice</title>
      <link>https://godeamon.github.io/post/go-slice/</link>
      <pubDate>Sat, 18 Apr 2020 11:32:30 +0800</pubDate>
      
      <guid>https://godeamon.github.io/post/go-slice/</guid>
      <description>&lt;h1 id=&#34;1切片是啥&#34;&gt;1.切片是啥&lt;/h1&gt;
&lt;p&gt;​		Go 的 **Slice（切片）**类型提供了一种方便有效的方法来处理类型化数据序列。 slice 与其他语言的数组类似却又不同，简单来说，切片更加灵活，用起来更方便，其原因就是可以扩容。&lt;/p&gt;
&lt;h1 id=&#34;2举例分析&#34;&gt;2.举例分析&lt;/h1&gt;
&lt;h2 id=&#34;21-认识切片第一步&#34;&gt;2.1. 认识切片第一步&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;sliceExample&lt;/span&gt;()
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sliceExample&lt;/span&gt;() {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;slc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
	&lt;span style=&#34;color:#a6e22e&#34;&gt;slc&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;slc&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;slc&lt;/span&gt;)

	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;slc1&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;slc1&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;slc1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;slc1&lt;/span&gt;)

	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;slc2&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;slc2&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;slc2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;slc2&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码是最基本的使用方式，首先看一下上面的代码在底层都做了哪些东西（不要害怕汇编，其实很简单，我们主要明白部分汇编代码即可）&lt;/p&gt;
&lt;p&gt;命令：&lt;code&gt;go tool compile -S slice.go&lt;/code&gt; 我的 go 文件为 slice.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;&amp;quot;&amp;quot;.main STEXT size=48 args=0x0 locals=0x8
	0x0000 00000 (slice.go:5)	TEXT	&amp;quot;&amp;quot;.main(SB), ABIInternal, $8-0
	......
	0x0021 00033 (slice.go:10)	PCDATA	$2, $1
	0x0021 00033 (slice.go:10)	PCDATA	$0, $0
	0x0021 00033 (slice.go:10)	LEAQ	type.int(SB), AX
	0x0028 00040 (slice.go:10)	PCDATA	$2, $0
	0x0028 00040 (slice.go:10)	MOVQ	AX, (SP)
	0x002c 00044 (slice.go:10)	XORPS	X0, X0
	0x002f 00047 (slice.go:10)	MOVUPS	X0, 8(SP)
	0x0034 00052 (slice.go:10)	CALL	runtime.makeslice(SB)
	0x0039 00057 (slice.go:10)	PCDATA	$2, $1
	0x0039 00057 (slice.go:10)	MOVQ	24(SP), AX
	0x003e 00062 (slice.go:11)	PCDATA	$2, $2
	0x003e 00062 (slice.go:11)	LEAQ	type.int(SB), CX
	0x0045 00069 (slice.go:11)	PCDATA	$2, $1
	0x0045 00069 (slice.go:11)	MOVQ	CX, (SP)
	0x0049 00073 (slice.go:11)	PCDATA	$2, $0
	0x0049 00073 (slice.go:11)	MOVQ	AX, 8(SP)
	0x004e 00078 (slice.go:11)	XORPS	X0, X0
	0x0051 00081 (slice.go:11)	MOVUPS	X0, 16(SP)
	0x0056 00086 (slice.go:11)	MOVQ	$1, 32(SP)
	0x005f 00095 (slice.go:11)	CALL	runtime.growslice(SB)
	0x0064 00100 (slice.go:11)	PCDATA	$2, $1
	0x0064 00100 (slice.go:11)	MOVQ	40(SP), AX
	0x0069 00105 (slice.go:11)	MOVQ	48(SP), CX
	0x006e 00110 (slice.go:11)	MOVQ	56(SP), DX
	0x0073 00115 (slice.go:11)	MOVQ	$1, (AX)
	0x007a 00122 (slice.go:12)	PCDATA	$2, $0
	0x007a 00122 (slice.go:12)	MOVQ	AX, (SP)
	0x007e 00126 (slice.go:11)	LEAQ	1(CX), AX
	0x0082 00130 (slice.go:12)	MOVQ	AX, 8(SP)
	0x0087 00135 (slice.go:12)	MOVQ	DX, 16(SP)
	0x008c 00140 (slice.go:12)	CALL	runtime.convTslice(SB)
	......
	0x00e8 00232 (slice.go:15)	PCDATA	$2, $1
	0x00e8 00232 (slice.go:15)	LEAQ	type.int(SB), AX
	0x00ef 00239 (slice.go:15)	PCDATA	$2, $0
	0x00ef 00239 (slice.go:15)	MOVQ	AX, (SP)
	0x00f3 00243 (slice.go:15)	XORPS	X0, X0
	0x00f6 00246 (slice.go:15)	MOVUPS	X0, 8(SP)
	0x00fb 00251 (slice.go:15)	MOVQ	$0, 24(SP)
	0x0104 00260 (slice.go:15)	MOVQ	$1, 32(SP)
	0x010d 00269 (slice.go:15)	CALL	runtime.growslice(SB)
	0x0112 00274 (slice.go:15)	PCDATA	$2, $1
	0x0112 00274 (slice.go:15)	MOVQ	40(SP), AX
	0x0117 00279 (slice.go:15)	MOVQ	48(SP), CX
	0x011c 00284 (slice.go:15)	MOVQ	56(SP), DX
	0x0121 00289 (slice.go:15)	MOVQ	$1, (AX)
	0x0128 00296 (slice.go:16)	PCDATA	$2, $0
	0x0128 00296 (slice.go:16)	MOVQ	AX, (SP)
	0x012c 00300 (slice.go:15)	LEAQ	1(CX), AX
	0x0130 00304 (slice.go:16)	MOVQ	AX, 8(SP)
	0x0135 00309 (slice.go:16)	MOVQ	DX, 16(SP)
	0x013a 00314 (slice.go:16)	CALL	runtime.convTslice(SB)
	......
	0x0196 00406 (slice.go:18)	PCDATA	$2, $1
	0x0196 00406 (slice.go:18)	LEAQ	type.[0]int(SB), AX
	0x019d 00413 (slice.go:18)	PCDATA	$2, $0
	0x019d 00413 (slice.go:18)	MOVQ	AX, (SP)
	0x01a1 00417 (slice.go:18)	CALL	runtime.newobject(SB)
	0x01a6 00422 (slice.go:19)	PCDATA	$2, $1
	0x01a6 00422 (slice.go:19)	LEAQ	type.int(SB), AX
	0x01ad 00429 (slice.go:19)	PCDATA	$2, $0
	0x01ad 00429 (slice.go:19)	MOVQ	AX, (SP)
	0x01b1 00433 (slice.go:19)	XORPS	X0, X0
	0x01b4 00436 (slice.go:19)	MOVUPS	X0, 16(SP)
	0x01b9 00441 (slice.go:19)	MOVQ	$1, 32(SP)
	0x01c2 00450 (slice.go:19)	CALL	runtime.growslice(SB)
	0x01c7 00455 (slice.go:19)	PCDATA	$2, $1
	0x01c7 00455 (slice.go:19)	MOVQ	40(SP), AX
	0x01cc 00460 (slice.go:19)	MOVQ	48(SP), CX
	0x01d1 00465 (slice.go:19)	MOVQ	56(SP), DX
	0x01d6 00470 (slice.go:19)	MOVQ	$1, (AX)
	0x01dd 00477 (slice.go:20)	PCDATA	$2, $0
	0x01dd 00477 (slice.go:20)	MOVQ	AX, (SP)
	0x01e1 00481 (slice.go:19)	LEAQ	1(CX), AX
	0x01e5 00485 (slice.go:20)	MOVQ	AX, 8(SP)
	0x01ea 00490 (slice.go:20)	MOVQ	DX, 16(SP)
	0x01ef 00495 (slice.go:20)	CALL	runtime.convTslice(SB)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面汇编我们不需要全部看明白只需要看懂6、11、15、23、34、37、44、55、58、61、69、80这几行就可以，也就是下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;slc := make([]int, 0)
slc = append(slc, 1)
fmt.Println(slc)
	
0x0021 00033 (slice.go:10)	LEAQ	type.int(SB), AX
0x0034 00052 (slice.go:10)	CALL	runtime.makeslice(SB)
0x003e 00062 (slice.go:11)	LEAQ	type.int(SB), CX
0x005f 00095 (slice.go:11)	CALL	runtime.growslice(SB)
0x008c 00140 (slice.go:12)	CALL	runtime.convTslice(SB)
============================
var slc1 []int
slc1 = append(slc1, 1)
fmt.Println(slc1)

0x00e8 00232 (slice.go:15)	LEAQ	type.int(SB), AX
0x010d 00269 (slice.go:15)	CALL	runtime.growslice(SB)
0x013a 00314 (slice.go:16)	CALL	runtime.convTslice(SB)
0x0196 00406 (slice.go:18)	LEAQ	type.[0]int(SB), AX
============================
slc2 := []int{}
slc2 = append(slc2, 1)
fmt.Println(slc2)

0x01a1 00417 (slice.go:18)	CALL	runtime.newobject(SB)
0x01c2 00450 (slice.go:19)	CALL	runtime.growslice(SB)
0x01ef 00495 (slice.go:20)	CALL	runtime.convTslice(SB)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​		为什么要看这些汇编代码呢？go 里面很多内置的方法我们是不能直接找到对应的实现函数的，所以我们通过这个 go tool compile 工具来看一下，就知道了。上面代码的第5、6行，就是 make slice 的实现，也就是说调用的函数就是 runtime 包中的 makeslice 函数。接下来的7、8行就是 appen 的具体实现，同样是 runtime 包，growslice 函数。第9行就是 fmt.Println 的具体实现，也就是 runtime.convTslice 函数。这样子我们就知道该去哪里看对应代码了。其实通过汇编能看到很多东西，这里我们只说 slice，以后有机会会继续和大家分享。&lt;/p&gt;
&lt;p&gt;​		上面的汇编代码我分为了三部分，也就是对应三中 slice 的声明，估计大家都看出来了，每种声明方式对应的实现函数都是不一样的，第一个是 runtime.makeslice，第二个没有对应的实现，第三个是 runtime.newobject，这三种方式区别还是有的，但是最终都可以实现我们的目标，因为最终都是调用了 runtime.mallocgc 函数，也就是分配内存，看到这有同学就会问了，第二种方式我们并没有对应的实现啊，也就是说并没有分配内存啊。是的，第二种方式我们确实没有直接分配内存，并且我们直接 append 了，其实是因为 append 操作会对没有分配内存的切片再分配一下内存（感兴趣的同学可以仔细看一下 growslice 源码）。所以我们在写代码时，使用 &lt;code&gt;var&lt;/code&gt; 关键字声明切片是完全可以的，并且对于长度为0的切片我们非常建议这样声明。&lt;/p&gt;
&lt;p&gt;​		我们简单看一下 &lt;code&gt;makeslice&lt;/code&gt; 代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;makeslice&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;et&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_type&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cap&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; {
    &lt;span style=&#34;color:#75715e&#34;&gt;// 判断 cap 是否溢出
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;mem&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;math&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;MulUintptr&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;et&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;, uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;cap&lt;/span&gt;))
    
    &lt;span style=&#34;color:#75715e&#34;&gt;// 溢出或者 len、cap 不符合要求
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mem&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxAlloc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cap&lt;/span&gt; {
		&lt;span style=&#34;color:#75715e&#34;&gt;// NOTE: Produce a &amp;#39;len out of range&amp;#39; error instead of a
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#39;cap out of range&amp;#39; error when someone does make([]T, bignumber).
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#39;cap out of range&amp;#39; is true too, but since the cap is only being
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// supplied implicitly, saying len is clearer.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// See golang.org/issue/4085.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;mem&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;math&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;MulUintptr&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;et&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;, uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt;))
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mem&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxAlloc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
			&lt;span style=&#34;color:#a6e22e&#34;&gt;panicmakeslicelen&lt;/span&gt;()
		}
		&lt;span style=&#34;color:#a6e22e&#34;&gt;panicmakeslicecap&lt;/span&gt;()
	}

    &lt;span style=&#34;color:#75715e&#34;&gt;// 真正的分配内存
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mallocgc&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;mem&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;et&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​		再看一下 &lt;code&gt;newobject&lt;/code&gt; 代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newobject&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;typ&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_type&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mallocgc&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;typ&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;typ&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​		没错，上面两个的最终都是调用 &lt;code&gt;mallocgc&lt;/code&gt; 函数。只不过 &lt;code&gt;makeslice&lt;/code&gt; 先做了一些判断。&lt;/p&gt;
&lt;h2 id=&#34;22-切片源码&#34;&gt;2.2. 切片源码&lt;/h2&gt;
&lt;p&gt;我们看一下切片的源码（go/src/runtime/slice.go）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;array&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;cap&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就是这么简单，一个切片就是三个字段，第一个是内存开始的指针，第二个是切片的长度，最后一个就是切片的容量。&lt;code&gt;slice.go&lt;/code&gt; 文件中其他函数都是针对切片的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;makeslice&lt;/code&gt;：初始化切片。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;makeslice64&lt;/code&gt;：初始化长度和容量为 int64 类型的切片，最终还是调用 &lt;code&gt;makeslice&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;growslice&lt;/code&gt;：切片扩容（内置 &lt;code&gt;append&lt;/code&gt; 函数）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slicecopy&lt;/code&gt;：切片的拷贝（内置 &lt;code&gt;copy&lt;/code&gt; 函数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23-切片和数组&#34;&gt;2.3. 切片和数组&lt;/h2&gt;
&lt;p&gt;切片是数组的片段，也就是说从数组上截取一段，然后我们切片可以在这个数组上“活动”，同样我们都可以使用下标来访问某个元素，但是如果我们给切片添加元素时，如果长度超过了当前数组的长度，那我们就再寻找一个新的内存，同样是新的数组、新的切片，但是对于我们代码使用者来说，切片还是不变的，但是它在内存的位置改变了。&lt;/p&gt;
&lt;h2 id=&#34;24-append&#34;&gt;2.4. append&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;append&lt;/code&gt; 应该是我们最常用的操作了，在文章开始部分我们已经看过简单的汇编语言了，并且已经知道其源码就是 &lt;code&gt;runtime/slice.go&lt;/code&gt; 中的 &lt;code&gt;growslice&lt;/code&gt; 函数。估计大家都知道切片是如何扩容的，网上大多数资料都是当原 slice 容量小于 &lt;code&gt;1024&lt;/code&gt; 的时候，新 slice 容量变成原来的 &lt;code&gt;2&lt;/code&gt; 倍；原 slice 容量超过 &lt;code&gt;1024&lt;/code&gt;，新 slice 容量变成原来的&lt;code&gt;1.25&lt;/code&gt;倍。这样说我们不能说完全正确，这样的说法还不算严谨。为啥不严谨呢，我们接着往下看。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;append&lt;/code&gt; 参数可以是多个，那么我们就有一下两种写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;}

&lt;span style=&#34;color:#75715e&#34;&gt;// append 多个元素
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;)

&lt;span style=&#34;color:#75715e&#34;&gt;// append 单个元素
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;d&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;e&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么这两种写法最后的切片 s 的长度和容量都是多少呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;} &lt;span style=&#34;color:#75715e&#34;&gt;// 此时切片长度为2，容量也为2。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;d&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;e&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// 结果：len=5, cap=8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;} &lt;span style=&#34;color:#75715e&#34;&gt;// 此时切片长度为2，容量也为2。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;e&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// 结果：len=5, cap=5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事实证明，不同的写法对切片最终的容量是有影响的。也就是说，对于 &lt;code&gt;append&lt;/code&gt; 多个参数时，并不会对每一个元素添加是都会进行扩容，而是对整体的所有元素来进行扩容，并且在元素类型不同时，最终的容量也是不同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;} &lt;span style=&#34;color:#75715e&#34;&gt;// 此时切片长度为2，容量也为2。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// 结果：len=5, cap=6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其原因是元素类型所占的内存大小是不一样的，从而导致 &lt;code&gt;append&lt;/code&gt; 操作时进行 &lt;strong&gt;内存对齐&lt;/strong&gt; 的结果也不一样（内存对齐这里不再赘述，以后有时间也会写类似文章）。所以我们上面三种代码最终的结果都是不同的。&lt;/p&gt;
&lt;p&gt;结论：在 appen 单个元素时，扩容规律确实是2倍或者1.25倍，但是appen 多个元素时，结果和元素类型是相关的，容量最小和长度相同。&lt;/p&gt;
&lt;h2 id=&#34;25-切片截取&#34;&gt;2.5. 切片截取&lt;/h2&gt;
&lt;p&gt;我们还要注意的是，扩容时如果容量大于原有数据的长度，我们重新分配内存，其操作不会影响原有的数据。但是没有分配新的内存，也就是说还是原来数组的基础上添加元素，那么新的切片操作就会影响原有的数组。这部分依然不再赘述，看一下下面代码，大家都明白了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;}
&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// len=4, cap=4
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [1 2 3 4]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [2]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// len=1, cap=3
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] = &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [1 5 3 4]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [5]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// len=2, cap=3
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] = &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [1 6 1 4]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [6 1]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// len=5, cap=6
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] = &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [1 6 1 4]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [7 1 1 2 3]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外还有一点，切片截取也是可以截取 cap 的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;}
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// len=4, cap=4
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	
&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// len=1, cap=2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	
&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;), cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// len=1, cap=3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;26-传递&#34;&gt;2.6. 传递&lt;/h2&gt;
&lt;p&gt;Go 语言函数参数都是值传递，在函数内部会拷贝一份，所以 slice 传递后拷贝一份都是新的 slice，但是 map 这种初始化之后就是一个 *hmap，所以参数传递后还是指向同一个 map（map 以后再详解）。&lt;/p&gt;
&lt;h2 id=&#34;27-总结&#34;&gt;2.7. 总结&lt;/h2&gt;
&lt;p&gt;切片暂时告一段落，最后总结一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;切片是对数组的封装，切片可以自动扩容。&lt;/li&gt;
&lt;li&gt;切片添加后，新的容量小于之前的容量，那么还是使用原有的数组，并且两者之间的元素修改有影响，因为底层是同一块内存。&lt;/li&gt;
&lt;li&gt;切片的扩容并不一定总是原有容量的2倍或者1.25倍，当 &lt;code&gt;append&lt;/code&gt; 多个元素时，会有内存对齐 ，最终的容量大于等于长度（这是一句废话，容量小于长度就 panic 了）。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;var&lt;/code&gt; 声明的切片可以直接 &lt;code&gt;append&lt;/code&gt;，并且我们建议这样，因为在声明时不会分配内存。&lt;/li&gt;
&lt;li&gt;已知切片容量或者长度时，声明时最好也指定容量或者长度，因为扩容导致重新分配内存消耗太大了。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Reading</title>
      <link>https://godeamon.github.io/post/reading/</link>
      <pubDate>Mon, 06 Apr 2020 10:48:25 +0800</pubDate>
      
      <guid>https://godeamon.github.io/post/reading/</guid>
      <description>&lt;p&gt;READING&lt;/p&gt;
&lt;p&gt;阅读中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;laquo;Unix 编程艺术&amp;raquo; 5%，好书。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;laquo;架构整洁之道&amp;raquo; 80%，如果你是架构，可以帮助你设计结构，如果你是执行者，帮助你理解架构。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;已完成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;laquo;操作系统导论&amp;raquo; 100%，打牢基础。属于内功吧。&lt;/li&gt;
&lt;li&gt;&amp;laquo;代码大全&amp;raquo; 100%，很多示例代码，有助于搬砖。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go Modules</title>
      <link>https://godeamon.github.io/post/go-modules/</link>
      <pubDate>Sat, 14 Mar 2020 23:06:15 +0800</pubDate>
      
      <guid>https://godeamon.github.io/post/go-modules/</guid>
      <description>&lt;h1 id=&#34;1-gopath&#34;&gt;1. GOPATH&lt;/h1&gt;
&lt;h2 id=&#34;11-简介&#34;&gt;1.1. 简介&lt;/h2&gt;
&lt;p&gt;​	GOPATH 大家肯定都非常熟悉了，想必大家第一次安装 Go 语言环境的时候已经了解了，这里就不多介绍了。但是大家在做项目时，对于 Go 的代码是如何管理的呢？我们很多时候会用到 &lt;code&gt;go get &lt;/code&gt; 命令，主要就是从 github 上将代码下载到本地，而下载的代码就存在本地 GOPATH 的位置。这样我们对于同一个包的多个版本的管理就有问题了。还有很多不方便的地方，这里就不一一列举了。因此有了  go modules 的解决方案。在此之前也有 vendor 的解决方案，今天主要就是和大家介绍一下如何使用 go modules 来管理项目。&lt;/p&gt;
&lt;h1 id=&#34;2-go-modules&#34;&gt;2. Go modules&lt;/h1&gt;
&lt;h2 id=&#34;21-简介&#34;&gt;2.1. 简介&lt;/h2&gt;
&lt;p&gt;​	modules 是在 Go 1.11 版本中提出来的，go1.12版功能不断改进，再到go1.13版完善优化，目前也是官方推荐的工具。并且也被认为是 GOPATH 的替代方式。也就是说，我们的 Go 代码可以不用在 &lt;code&gt;$GOPATH/src&lt;/code&gt; 下了（不知道大家有没有觉得轻松了）。&lt;/p&gt;
&lt;h2 id=&#34;22-安装&#34;&gt;2.2. 安装&lt;/h2&gt;
&lt;p&gt;​	modules 的安装非常简单，安装 GO 1.13 版本或者升级到此版本。比此版本低个人不建议使用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://godeamon.github.io/post/about-me/</link>
      <pubDate>Sat, 14 Mar 2020 15:12:41 +0800</pubDate>
      
      <guid>https://godeamon.github.io/post/about-me/</guid>
      <description>&lt;h1 id=&#34;我&#34;&gt;我&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;毕业于北华大学。&lt;/li&gt;
&lt;li&gt;现就职北京一家区块链公司。&lt;/li&gt;
&lt;li&gt;热爱 Go 语言，热爱分享，热爱开源。&lt;/li&gt;
&lt;li&gt;email：rayforce.lee@gmail.com&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>